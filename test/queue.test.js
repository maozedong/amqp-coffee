// Generated by CoffeeScript 2.3.1
(function() {
  var AMQP, _, async, proxy, should, uuid;

  should = require('should');

  async = require('async');

  _ = require('underscore');

  proxy = require('./proxy');

  uuid = require('uuid').v4;

  AMQP = require('../src/amqp');

  describe('Queue', function() {
    it('test it can declare a queue 500', function(done) {
      var amqp, queue;
      amqp = null;
      queue = null;
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue: "testing"
          },
        function(e,
        q) {
            should.not.exist(e);
            should.exist(q);
            queue = q;
            return next();
          });
        },
        function(next) {
          return queue.declare({
            passive: false
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return queue.delete(next);
        }
      ], done);
    });
    it('test it can declare a queue with no name 5001', function(done) {
      var amqp, queue;
      amqp = null;
      queue = null;
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue: ''
          },
        function(e,
        q) {
            should.not.exist(e);
            should.exist(q);
            queue = q;
            return next();
          });
        },
        function(next) {
          return queue.declare({
            passive: false
          },
        function(e,
        r) {
            should.not.exist(e);
            should.exist(r.queue);
            return next();
          });
        },
        function(next) {
          return queue.bind("amq.direct",
        uuid(),
        next);
        },
        function(next) {
          queue.queueOptions.queue.should.not.eql('');
          return next();
        }
      ], function(err, res) {
        should.not.exist(err);
        return done();
      });
    });
    it('test it can get a queues message count 501', function(done) {
      var amqp, queue, queuename;
      amqp = null;
      queue = null;
      queuename = uuid();
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue: queuename
          },
        function(e,
        q) {
            should.not.exist(e);
            should.exist(q);
            queue = q;
            return next();
          });
        },
        function(next) {
          return queue.declare({
            passive: false
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return queue.bind("amq.direct",
        queuename,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return queue.messageCount(function(err,
        res) {
            res.should.eql(0);
            return next();
          });
        },
        function(next) {
          return amqp.publish("amq.direct",
        queuename,
        "test message",
        {
            confirm: true
          },
        function(e,
        r) {
            return next();
          });
        },
        function(next) {
          return queue.messageCount(function(err,
        res) {
            res.should.eql(1);
            return next();
          });
        },
        function(next) {
          return queue.delete({
            ifEmpty: false
          },
        next);
        },
        function(next) {
          amqp.close();
          return next();
        }
      ], done);
    });
    it('test it can get a queues consumer count 502', function(done) {
      var amqp, queue;
      amqp = null;
      queue = null;
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue: "testing"
          },
        function(e,
        q) {
            should.not.exist(e);
            should.exist(q);
            queue = q;
            return next();
          });
        },
        function(next) {
          return queue.declare({
            passive: false
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return queue.bind("amq.direct",
        "testing",
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return queue.consumerCount(function(err,
        res) {
            res.should.eql(0);
            return next();
          });
        },
        function(next) {
          var processor;
          processor = function() {};
          // i do nothing :)
          return amqp.consume("testing",
        {},
        processor,
        next);
        },
        function(next) {
          return queue.consumerCount(function(err,
        res) {
            res.should.eql(1);
            return next();
          });
        },
        function(next) {
          return queue.delete(next);
        },
        function(next) {
          amqp.close();
          return next();
        }
      ], done);
    });
    it('test it can get a queues consumer count with connection trouble 503', function(done) {
      var amqp, queue, thisproxy;
      thisproxy = new proxy.route(7008, 5672, "localhost");
      amqp = null;
      queue = null;
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost',
            port: 7008,
            heartbeat: 1000
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue: "testing"
          },
        function(e,
        q) {
            should.not.exist(e);
            should.exist(q);
            queue = q;
            return next();
          });
        },
        function(next) {
          return queue.declare({
            passive: false
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return queue.bind("amq.direct",
        "testing",
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return queue.consumerCount(function(err,
        res) {
            res.should.eql(0);
            thisproxy.interrupt();
            return next();
          });
        },
        function(next) {
          var processor;
          processor = function() {};
          // i do nothing :)
          return amqp.consume("testing",
        {},
        processor,
        next);
        },
        function(next) {
          return queue.consumerCount(function(err,
        res) {
            res.should.eql(1);
            return next();
          });
        },
        function(next) {
          return queue.delete(next);
        },
        function(next) {
          amqp.close();
          thisproxy.close();
          return next();
        }
      ], done);
    });
    it('test it can get a queues consumer count with connection trouble 504', function(done) {
      var amqp, queue, thisproxy;
      this.timeout(5000);
      thisproxy = new proxy.route(7008, 5672, "localhost");
      amqp = null;
      queue = null;
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost',
            port: 7008,
            heartbeat: 30000
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue: "testing",
            autoDelete: false,
            durable: true
          },
        function(e,
        q) {
            should.not.exist(e);
            should.exist(q);
            queue = q;
            return next();
          });
        },
        function(next) {
          return queue.declare({
            passive: false
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return queue.bind("amq.direct",
        "testing",
        function(e,
        r) {
            should.not.exist(e);
            thisproxy.close();
            return next();
          });
        },
        function(next) {
          queue.consumerCount(function(err,
        res) {
            should.exist(err);
            thisproxy.interrupt();
            return next();
          });
          return _.delay(function() {
            return thisproxy.listen();
          },
        1000);
        },
        function(next) {
          return queue.consumerCount(function(err,
        res) {
            res.should.eql(0);
            return next();
          });
        },
        function(next) {
          return queue.delete(next);
        },
        function(next) {
          amqp.close();
          thisproxy.close();
          return next();
        }
      ], done);
    });
    it('test it can declare a queue while its trying to close a temp channel 632', function(done) {
      var amqp, channel, queue;
      amqp = null;
      queue = null;
      channel = null;
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return channel = amqp.queue({
            queue: "testing"
          },
        function(e,
        q) {
            should.not.exist(e);
            should.exist(q);
            queue = q;
            return next();
          });
        },
        function(next) {
          channel.close();
          return queue.declare({
            passive: false
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return queue.delete(next);
        }
      ], done);
    });
    it('test it can declare a queue while its trying to close a temp channel deferred 633', function(done) {
      var amqp, channel, queue;
      amqp = null;
      queue = null;
      channel = null;
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return channel = amqp.queue({
            queue: "testing"
          },
        function(e,
        q) {
            should.not.exist(e);
            should.exist(q);
            queue = q;
            return next();
          });
        },
        function(next) {
          queue.declare({
            passive: false
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
          return setTimeout(channel.close,
        1);
        },
        function(next) {
          return queue.delete(next);
        }
      ], done);
    });
    it('test it can delete a queue', function(done) {
      var amqp, queue;
      amqp = null;
      queue = null;
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue: "testing"
          },
        function(e,
        q) {
            should.not.exist(e);
            should.exist(q);
            queue = q;
            return next();
          });
        },
        function(next) {
          return queue.declare({
            passive: false
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return queue.delete({},
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        }
      ], done);
    });
    it('test we can bind a queue', function(done) {
      var amqp, queue, queueName;
      amqp = null;
      queue = null;
      queueName = uuid();
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue: queueName
          },
        function(e,
        q) {
            should.not.exist(e);
            should.exist(q);
            queue = q;
            return next();
          });
        },
        function(next) {
          return queue.declare({
            passive: false
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return queue.bind("amq.direct",
        queueName,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        }
      ], done);
    });
    it('test we can bind queue to headers with custom arguments', function(done) {
      var amqp, queue, queueName;
      amqp = null;
      queue = null;
      queueName = uuid();
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue: queueName
          },
        function(e,
        q) {
            should.not.exist(e);
            should.exist(q);
            queue = q;
            return next();
          });
        },
        function(next) {
          return queue.declare({
            passive: false
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          var opts;
          opts = {
            arguments: {
              'x-routing-key': queueName
            }
          };
          return queue.bind("amq.match",
        "",
        opts,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        }
      ], done);
    });
    it('test we do not error on a double bind', function(done) {
      var amqp, queue, queueName;
      amqp = null;
      queue = null;
      queueName = uuid();
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue: queueName
          },
        function(e,
        q) {
            should.not.exist(e);
            should.exist(q);
            queue = q;
            return next();
          });
        },
        function(next) {
          return queue.declare({
            passive: false
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return queue.bind("amq.direct",
        "testing",
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return queue.bind("amq.direct",
        "testing",
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return queue.delete(next);
        }
      ], done);
    });
    it('test we can unbind a queue 2885', function(done) {
      var amqp, queue, queueName;
      this.timeout(1000000);
      amqp = null;
      queue = null;
      queueName = uuid();
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue: queueName
          },
        function(e,
        q) {
            should.not.exist(e);
            should.exist(q);
            queue = q;
            return next();
          });
        },
        function(next) {
          return queue.declare({
            passive: false
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return queue.bind("amq.direct",
        "testing",
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return queue.bind("amq.direct",
        "testing2",
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return queue.unbind("amq.direct",
        "testing",
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return queue.unbind("amq.direct",
        "testing2",
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return _.delay(function() {
            var channel,
        channelNumber,
        openChannels,
        ref;
            openChannels = 0;
            ref = amqp.channels;
            for (channelNumber in ref) {
              channel = ref[channelNumber];
              if (channel.state === 'open') {
                openChannels++;
              }
            }
            openChannels.should.eql(2);
            return next();
          },
        10);
        },
        function(next) {
          return _.delay(function() {
            var channel,
        channelNumber,
        openChannels,
        ref;
            openChannels = 0;
            ref = amqp.channels;
            for (channelNumber in ref) {
              channel = ref[channelNumber];
              if (channel.state === 'open') {
                openChannels++;
              }
            }
            openChannels.should.eql(1);
            return next();
          },
        500);
        },
        function(next) {
          return queue.delete(next);
        }
      ], done);
    });
    it('test we can unbind a queue with no callbacks 2886', function(done) {
      var amqp, queue, queueName;
      amqp = null;
      queue = null;
      queueName = uuid();
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue: queueName
          },
        function(e,
        q) {
            should.not.exist(e);
            should.exist(q);
            queue = q;
            return next();
          });
        },
        function(next) {
          return queue.declare({
            passive: false
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          queue.bind("amq.direct",
        "test1");
          queue.bind("amq.direct",
        "test2");
          queue.bind("amq.direct",
        "test3");
          return _.delay(next,
        30);
        },
        function(next) {
          queue.unbind("amq.direct",
        "test1");
          queue.unbind("amq.direct",
        "test2");
          queue.unbind("amq.direct",
        "test3");
          return _.delay(next,
        500);
        },
        function(next) {
          var channel,
        channelNumber,
        openChannels,
        ref;
          openChannels = 0;
          ref = amqp.channels;
          for (channelNumber in ref) {
            channel = ref[channelNumber];
            if (channel.state === 'open') {
              openChannels++;
            }
          }
          openChannels.should.eql(1);
          return next();
        }
      ], done);
    });
    it('test we can unbind a queue with no callbacks on bad binds 2887', function(done) {
      var amqp, consumer, queue, queueName;
      amqp = null;
      queue = null;
      queueName = uuid();
      consumer = null;
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue: queueName,
            passive: false,
            exclusive: true,
            autodelete: true
          },
        function(e,
        q) {
            should.not.exist(e);
            should.exist(q);
            queue = q;
            return next();
          });
        },
        function(next) {
          return queue.declare(function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return consumer = amqp.consume(queueName,
        {},
        function(message) {
            return console.error(messge);
          },
        function(cb) {
            return next();
          });
        },
        function(next) {
          queue.bind("amq.direct",
        "test1");
          queue.bind("amq.direct",
        "test2");
          queue.bind("amq.direct",
        "test3");
          queue.bind("amq.direct2",
        "test5");
          return _.delay(next,
        30);
        },
        function(next) {
          queue.unbind("amq.direct",
        "test1");
          queue.unbind("amq.direct",
        "test2");
          queue.unbind("amq.direct",
        "test3");
          queue.unbind("amq.direct",
        "test4");
          return _.delay(next,
        500);
        },
        function(next) {
          queue.unbind("amq.direct",
        "test1");
          queue.unbind("amq.direct",
        "test2");
          queue.unbind("amq.direct",
        "test3");
          queue.unbind("amq.direct",
        "test4");
          queue.unbind("amq.direct",
        "test4");
          return _.delay(next,
        500);
        },
        function(next) {
          consumer.close();
          return _.delay(next,
        50);
        },
        function(next) {
          var channel,
        channelNumber,
        openChannels,
        ref;
          openChannels = 0;
          ref = amqp.channels;
          for (channelNumber in ref) {
            channel = ref[channelNumber];
            if (channel.state === 'open') {
              openChannels++;
            }
          }
          openChannels.should.eql(1);
          return next();
        }
      ], done);
    });
    it('test we can bind to a non-existing exchange and not leave channels open 2889', function(done) {
      var amqp, queue, queueName;
      amqp = null;
      queue = null;
      queueName = uuid();
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue: queueName,
            passive: false,
            exclusive: true,
            autodelete: true
          },
        function(e,
        q) {
            should.not.exist(e);
            should.exist(q);
            queue = q;
            return next();
          });
        },
        function(next) {
          return queue.declare(function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return queue.bind("amq.direct2",
        "test1",
        function() {
            return next();
          });
        },
        function(next) {
          return queue.bind("amq.direct2",
        "test1",
        function() {
            return next();
          });
        },
        function(next) {
          return _.delay(next,
        100);
        },
        function(next) {
          return queue.bind("amq.direct2",
        "test1",
        function() {
            return next();
          });
        },
        function(next) {
          return queue.bind("amq.direct2",
        "test1",
        function() {
            return next();
          });
        },
        function(next) {
          return _.delay(next,
        500);
        },
        function(next) {
          var channel,
        channelNumber,
        openChannels,
        ref;
          openChannels = 0;
          ref = amqp.channels;
          for (channelNumber in ref) {
            channel = ref[channelNumber];
            if (channel.state === 'open') {
              openChannels++;
            }
          }
          openChannels.should.eql(1);
          return next();
        }
      ], done);
    });
    it('test we can timeout a queue channel and reopen it', function(done) {
      var amqp, queue, queueName;
      this.timeout(2000);
      amqp = null;
      queue = null;
      queueName = uuid();
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue: queueName
          },
        function(e,
        q) {
            should.not.exist(e);
            should.exist(q);
            queue = q;
            return next();
          });
        },
        function(next) {
          return queue.declare({
            passive: false
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          _.keys(amqp.channels).length.should.eql(2);
          return _.delay(next,
        500);
        },
        function(next) {
          _.keys(amqp.channels).length.should.eql(1);
          return next();
        },
        function(next) {
          return queue.declare({
            passive: false
          },
        function(e,
        r) {
            should.not.exist(e);
            _.keys(amqp.channels).length.should.eql(2);
            return next();
          });
        }
      ], done);
    });
    it('test after a unbind error we could rebind, on a different channel', function(done) {
      var amqp, channel, queue, queueName;
      amqp = null;
      queue = null;
      queueName = uuid();
      channel = null;
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return channel = amqp.queue({
            queue: queueName
          },
        function(e,
        q) {
            should.not.exist(e);
            should.exist(q);
            queue = q;
            return next();
          });
        },
        function(next) {
          return queue.declare({
            passive: false
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return queue.bind("amq.direct",
        "testing",
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return queue.unbind("amq.direct",
        "testing",
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return channel.crash(next);
        },
        function(next) {
          return queue.bind("amq.direct",
        "testing",
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        }
      ], done);
    });
    it('test we get a error on a bad bind', function(done) {
      var amqp, channel, queue, queueName;
      amqp = null;
      queue = null;
      queueName = uuid();
      channel = null;
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return channel = amqp.queue({
            queue: queueName
          },
        function(e,
        q) {
            should.not.exist(e);
            should.exist(q);
            queue = q;
            return next();
          });
        },
        function(next) {
          return queue.bind("amq.direct",
        "testing",
        function(e,
        r) {
            should.exist(e);
            e.replyCode.should.eql(404);
            return next();
          });
        }
      ], done);
    });
    return it('test it can declare a AD queue twice 5897', function(done) {
      var amqp, amqp2, eventFired;
      amqp = null;
      amqp2 = null;
      eventFired = 0;
      return async.series([
        function(next) {
          amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
          return amqp.on('error',
        function(e) {
            should.not.exist(e);
            return eventFired++;
          });
        },
        function(next) {
          var queue;
          queue = amqp.queue({
            queue: 'testQueueHA',
            durable: true,
            autoDelete: true
          },
        function(e,
        q) {
            should.not.exist(e);
            eventFired++;
            return q.declare({},
        function(e) {
              should.not.exist(e);
              eventFired++;
              return next();
            });
          });
          return queue.on('error',
        function(e) {
            should.not.exist(e);
            return eventFired++;
          });
        },
        function(next) {
          return amqp2 = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          var queue;
          amqp2.on('error',
        function(e) {
            should.not.exist(e);
            return eventFired++;
          });
          queue = amqp2.queue({
            queue: 'testQueueHA',
            durable: true,
            autoDelete: false
          },
        function(e,
        q) {
            should.not.exist(e);
            eventFired++;
            return q.declare({},
        function(e) {
              should.exist(e);
              eventFired++;
              return next();
            });
          });
          return queue.on('error',
        function(e) {
            should.not.exist(e);
            return eventFired++;
          });
        }
      ], function(err, res) {
        should.not.exist(err);
        eventFired.should.eql(4);
        return _.delay(done, 1000);
      });
    });
  });

}).call(this);
