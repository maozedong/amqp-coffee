// Generated by CoffeeScript 2.3.1
(function() {
  var AMQP, BSON, FrameType, HeartbeatFrame, MaxFrameSize, _, async, bson, proxy, should, uuid;

  should = require('should');

  async = require('async');

  _ = require('underscore');

  proxy = require('./proxy');

  uuid = require('uuid').v4;

  AMQP = require('../src/amqp');

  BSON = require('bson');

  bson = new BSON();

  ({MaxFrameSize, FrameType, HeartbeatFrame} = require('../src/lib/config').constants);

  describe('Consumer', function() {
    this.timeout(10000);
    it('test we can consume a queue and get a message', function(done) {
      var amqp, messageProcessor, queue, testData;
      testData = {
        test: "message"
      };
      amqp = null;
      queue = uuid();
      messageProcessor = function(m) {
        m.data.should.eql(testData);
        return done();
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({queue},
        function(e,
        q) {
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return amqp.consume(queue,
        {},
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.publish("amq.direct",
        queue,
        testData,
        {
            confirm: true
          },
        next);
        }
      ]);
    });
    it('test we can consume a queue and get a message with headers 163', function(done) {
      var amqp, messageProcessor, queue, testData;
      testData = {
        test: "message"
      };
      amqp = null;
      queue = uuid();
      messageProcessor = function(m) {
        m.data.should.eql(testData);
        return done();
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({queue},
        function(e,
        q) {
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return amqp.consume(queue,
        {},
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.publish("amq.direct",
        queue,
        testData,
        {
            confirm: true
          },
        next);
        }
      ]);
    });
    it('test we can set up a bunch of consumes 164', function(done) {
      var amqp, messageProcessor, queue;
      amqp = null;
      queue = uuid();
      messageProcessor = function() {};
      // do nothing
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({queue},
        function(e,
        q) {
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return async.forEach([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19],
        function(i,
        done) {
            return amqp.consume(queue,
        {},
        messageProcessor,
        function(e,
        r) {
              should.not.exist(e);
              return done();
            });
          },
        next);
        }
      ], done);
    });
    it('test we fail correctly with a exclusive consumer 165', function(done) {
      var amqp, messageProcessor, queue;
      amqp = null;
      queue = uuid();
      messageProcessor = function() {};
      // do nothing
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({queue},
        function(e,
        q) {
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return amqp.consume(queue,
        {
            exclusive: true
          },
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.consume(queue,
        {
            exclusive: true
          },
        messageProcessor,
        function(e,
        r) {
            should.exist(e);
            return next();
          });
        }
      ], function(err, res) {
        should.not.exist(err);
        return done();
      });
    });
    it('test we can consume a queue and get a message, and keep it intact', function(done) {
      var amqp, messageProcessor, queue, testData;
      testData = {
        test: "message"
      };
      amqp = null;
      queue = uuid();
      messageProcessor = function(m) {
        var message;
        message = m.data;
        message.should.eql(testData);
        message = {
          test: false
        };
        message.should.not.eql(testData);
        message = m.data;
        message.should.eql(testData);
        return done();
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({queue},
        function(e,
        q) {
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return amqp.consume(queue,
        {},
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.publish("amq.direct",
        queue,
        testData,
        {
            confirm: true
          },
        next);
        }
      ]);
    });
    it('test we can consume a queue and get some messages, and keep them intact 587', function(done) {
      var amqp, messageN, messageProcessor, messages, queue, testData;
      testData = [
        {
          test: "message1"
        },
        {
          test: "message2"
        }
      ];
      amqp = null;
      queue = uuid();
      messageN = 0;
      messages = [];
      messageProcessor = function(m) {
        var j, len, mcheck, message, thisMessage;
        thisMessage = messageN;
        messageN++;
        message = m.data;
        message.should.eql(testData[thisMessage]);
        message = {
          test: false
        };
        message.should.not.eql(testData[thisMessage]);
        message = m.data;
        message.should.eql(testData[thisMessage]);
        messages.push(m);
        if (messageN === 2) {
          mcheck = 0;
          for (j = 0, len = messages.length; j < len; j++) {
            message = messages[j];
            message.data.should.eql(testData[mcheck]);
            mcheck++;
          }
          return done();
        }
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({queue},
        function(e,
        q) {
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return amqp.consume(queue,
        {},
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.publish("amq.direct",
        queue,
        testData[0],
        {
            confirm: true
          },
        next);
        },
        function(next) {
          return amqp.publish("amq.direct",
        queue,
        testData[1],
        {
            confirm: true
          },
        next);
        }
      ]);
    });
    it('test we can consume a queue and get a big message 588', function(done) {
      var amqp, messageProcessor, queue, testData;
      testData = Buffer.alloc(MaxFrameSize * 3.5);
      amqp = null;
      queue = uuid();
      messageProcessor = function(m) {
        var byte, i, j, len, ref;
        m.data.length.should.eql(testData.length);
        ref = m.data;
        // byte by byte comparison replaces # m.data.should.eql testData
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          byte = ref[i];
          if (byte !== testData[i]) {
            throw new Error("data is incorrect");
          }
        }
        return done();
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({queue},
        function(e,
        q) {
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return amqp.consume(queue,
        {},
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.publish("amq.direct",
        queue,
        testData,
        {
            confirm: true
          },
        next);
        }
      ]);
    });
    it('test we can consume a queue several really big messages 173', function(done) {
      var amqp, messageProcessor, messagesRecieved, messagesToSend, queue, testData;
      this.timeout(120000);
      testData = Buffer.alloc(10 * 1024 * 1024); // 10 mb ish
      amqp = null;
      queue = uuid();
      messagesToSend = 10;
      messagesRecieved = 0;
      messageProcessor = function(m) {
        var byte, i, j, len, ref;
        m.data.length.should.eql(testData.length);
        ref = m.data;
        // byte by byte comparison replaces # m.data.should.eql testData
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          byte = ref[i];
          if (byte !== testData[i]) {
            throw new Error("data is incorrect");
          }
        }
        messagesRecieved++;
        if (messagesRecieved === messagesToSend) {
          return done();
        }
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({queue},
        function(e,
        q) {
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return amqp.consume(queue,
        {},
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return async.forEach((function() {
            var results = [];
            for (var j = 0; 0 <= messagesToSend ? j < messagesToSend : j > messagesToSend; 0 <= messagesToSend ? j++ : j--){ results.push(j); }
            return results;
          }).apply(this),
        function(i,
        next) {
            return amqp.publish("amq.direct",
        queue,
        testData,
        {
              confirm: false
            },
        next);
          },
        next);
        }
      ], function(e, r) {
        return should.not.exist(e);
      });
    });
    it('test we can consume a queue and get a JSON big message', function(done) {
      var amqp, messageProcessor, queue, t, testData;
      t = Buffer.alloc(MaxFrameSize * 3.5);
      testData = {
        t: t.toString()
      };
      amqp = null;
      queue = uuid();
      messageProcessor = function(m) {
        m.data.should.eql(testData);
        return done();
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({queue},
        function(e,
        q) {
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return amqp.consume(queue,
        {},
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.publish("amq.direct",
        queue,
        testData,
        {
            confirm: true
          },
        next);
        }
      ]);
    });
    it('test we can consume a queue and get a BSON big message 142', function(done) {
      var amqp, messageProcessor, queue, t, testData;
      t = Buffer.alloc(MaxFrameSize * 3.5);
      testData = {
        t: t.toString()
      };
      amqp = null;
      queue = uuid();
      messageProcessor = function(m) {
        m.data.should.eql(testData);
        return done();
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({queue},
        function(e,
        q) {
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return amqp.consume(queue,
        {},
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          // testData = BSON.serialize testData
          return amqp.publish("amq.direct",
        queue,
        bson.serialize(testData),
        {
            contentType: "application/bson",
            confirm: true
          },
        next);
        }
      ], function(e, r) {
        return should.not.exist(e);
      });
    });
    it('test we can consume and get max messages', function(done) {
      var amqp, messageProcessor, messagesRecieved, queue, testData;
      testData = {
        test: "message"
      };
      amqp = null;
      queue = uuid();
      messagesRecieved = 0;
      messageProcessor = function(m) {
        m.data.should.eql(testData);
        messagesRecieved++;
        if (messagesRecieved === 1) {
          _.delay(function() {
            messagesRecieved.should.eql(2);
            return m.ack();
          }, 50);
        }
        if (messagesRecieved === 3) {
          return _.delay(function() {
            messagesRecieved.should.eql(3);
            return done();
          });
        }
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({queue},
        function(e,
        q) {
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return async.forEach([0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
        function(i,
        done) {
            return amqp.publish("amq.direct",
        queue,
        testData,
        {
              confirm: true
            },
        done);
          },
        next);
        },
        function(next) {
          return amqp.consume(queue,
        {
            prefetchCount: 2
          },
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        }
      ]);
    });
    it('test we can consume and change prefetchCount 700', function(done) {
      var amqp, consumer, messageProcessor, messagesRecieved, queue, queueConnection, testData;
      testData = {
        test: "message"
      };
      amqp = null;
      queue = uuid();
      messagesRecieved = 0;
      queueConnection = null;
      consumer = null;
      messageProcessor = function(m) {
        m.data.should.eql(testData);
        messagesRecieved++;
        if (messagesRecieved === 1) {
          _.delay(function() {
            messagesRecieved.should.eql(2);
            return consumer.setQos(5, function() {
              return m.ack();
            });
          }, 50);
        }
        if (messagesRecieved === 3) {
          return _.delay(function() {
            messagesRecieved.should.eql(6);
            queueConnection.delete({
              isEmpty: false
            });
            amqp.close();
            return done();
          }, 50);
        }
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({queue},
        function(e,
        q) {
            queueConnection = q;
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return async.forEach([0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
        function(i,
        done) {
            return amqp.publish("amq.direct",
        queue,
        testData,
        {
              confirm: true
            },
        done);
          },
        next);
        },
        function(next) {
          var consumerOptions,
        ref,
        ref1,
        ref2,
        ref3;
          consumerOptions = {
            prefetchCount: 2
          };
          if (((ref = amqp.serverProperties) != null ? ref.product : void 0) === 'RabbitMQ' && (((ref1 = amqp.serverProperties) != null ? (ref2 = ref1.capabilities) != null ? ref2.per_consumer_qos : void 0 : void 0) === true || ((ref3 = amqp.serverProperties) != null ? ref3.version : void 0) === "3.3.0")) {
            consumerOptions.global = true;
          }
          return consumer = amqp.consume(queue,
        consumerOptions,
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        }
      ]);
    });
    it('test we can consume a bunch of messages 215', function(done) {
      var amqp, messageProcessor, messagesRecieved, queue, testData;
      testData = {
        test: "message"
      };
      amqp = null;
      queue = uuid();
      messagesRecieved = 0;
      messageProcessor = function(m) {
        m.data.should.eql(testData);
        messagesRecieved++;
        if (messagesRecieved === 500) {
          return _.delay(function() {
            messagesRecieved.should.eql(500);
            return done();
          }, 50);
        }
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({queue},
        function(e,
        q) {
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return async.forEach((function() {
            var results = [];
            for (var j = 0; j < 500; j++){ results.push(j); }
            return results;
          }).apply(this),
        function(i,
        done) {
            return amqp.publish("amq.direct",
        queue,
        testData,
        {
              confirm: true
            },
        done);
          },
        next);
        },
        function(next) {
          return amqp.consume(queue,
        {
            prefetchCount: 500
          },
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        }
      ]);
    });
    it('test we can use flow control 496', function(done) {
      var amqp, consumer, messageProcessor, messagesRecieved, queue, testData;
      testData = {
        test: "message"
      };
      amqp = null;
      queue = uuid();
      messagesRecieved = 0;
      consumer = null;
      messageProcessor = function(m) {
        m.data.should.eql(testData);
        messagesRecieved++;
        if (messagesRecieved === 10) {
          consumer.pause();
          _.delay(function() {
            messagesRecieved.should.eql(10);
            return consumer.resume();
          }, 500);
        }
        _.delay(function() {
          return m.ack();
        }, 50);
        if (messagesRecieved === 50) {
          return _.delay(function() {
            messagesRecieved.should.eql(50);
            return done();
          }, 50);
        }
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            autoDelete: false,
            queue
          },
        function(e,
        q) {
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return async.forEach((function() {
            var results = [];
            for (var j = 0; j < 50; j++){ results.push(j); }
            return results;
          }).apply(this),
        function(i,
        done) {
            return amqp.publish("amq.direct",
        queue,
        testData,
        {
              confirm: true
            },
        done);
          },
        next);
        },
        function(next) {
          return consumer = amqp.consume(queue,
        {
            prefetchCount: 10
          },
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        }
      ]);
    });
    it('test we can consume and reject a message', function(done) {
      var amqp, messageProcessor, messagesRecieved, queue, testData;
      testData = {
        test: "message"
      };
      amqp = null;
      queue = uuid();
      messagesRecieved = 0;
      messageProcessor = function(m) {
        m.data.should.eql(testData);
        messagesRecieved++;
        _.delay(function() {
          return m.reject();
        }, 50);
        if (messagesRecieved === 5) {
          return _.delay(function() {
            messagesRecieved.should.eql(5);
            return done();
          });
        }
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({queue},
        function(e,
        q) {
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return async.forEach([0, 1, 2, 3, 4],
        function(i,
        done) {
            return amqp.publish("amq.direct",
        queue,
        testData,
        {
              confirm: true
            },
        done);
          },
        next);
        },
        function(next) {
          return amqp.consume(queue,
        {
            prefetchCount: 2
          },
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        }
      ]);
    });
    it('test we can consume and retry a message', function(done) {
      var amqp, messageProcessor, messagesRecieved, queue, testData;
      testData = {
        test: "message"
      };
      amqp = null;
      queue = uuid();
      messagesRecieved = 0;
      messageProcessor = function(m) {
        m.data.should.eql(testData);
        messagesRecieved++;
        if (messagesRecieved <= 2) {
          m.retry();
        } else {
          m.ack();
        }
        if (messagesRecieved === 2) {
          return _.delay(function() {
            messagesRecieved.should.eql(5);
            return done();
          }, 200);
        }
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({queue},
        function(e,
        q) {
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return async.forEach([0, 1, 2],
        function(i,
        done) {
            return amqp.publish("amq.direct",
        queue,
        testData,
        {
              confirm: true
            },
        done);
          },
        next);
        },
        function(next) {
          return amqp.consume(queue,
        {
            prefetchCount: 2
          },
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        }
      ]);
    });
    it('test we can consume and deal with a crash mid stream 705', function(done) {
      var amqp, consumer, messageProcessor, messagesRecieved, queue, testData;
      testData = {
        test: "message"
      };
      amqp = null;
      queue = uuid();
      messagesRecieved = 0;
      consumer = null;
      messageProcessor = function(m) {
        m.data.should.eql(testData);
        messagesRecieved++;
        if (messagesRecieved === 1) {
          _.delay(function() {
            messagesRecieved.should.eql(2);
            consumer.crash();
            return m.ack();
          }, 50);
        }
        if (messagesRecieved === 4) {
          return _.delay(function() {
            messagesRecieved.should.eql(4);
            return done();
          });
        }
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue,
            autoDelete: false
          },
        function(e,
        q) {
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return async.forEach([0, 1, 2],
        function(i,
        done) {
            return amqp.publish("amq.direct",
        queue,
        testData,
        {
              confirm: true
            },
        done);
          },
        next);
        },
        function(next) {
          return consumer = amqp.consume(queue,
        {
            prefetchCount: 2
          },
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        }
      ]);
    });
    it('test we can consume and cancel the consumer', function(done) {
      var amqp, consumer, messageProcessor, messagesRecieved, queue, testData;
      testData = {
        test: "message"
      };
      amqp = null;
      queue = uuid();
      messagesRecieved = 0;
      consumer = null;
      messageProcessor = function(m) {
        m.data.should.eql(testData);
        messagesRecieved++;
        if (messagesRecieved === 1) {
          consumer.cancel(function() {
            return m.ack();
          });
          return _.delay(function() {
            messagesRecieved.should.eql(1);
            return done();
          }, 300);
        }
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue,
            autoDelete: false
          },
        function(e,
        q) {
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return async.forEach([0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
        function(i,
        done) {
            return amqp.publish("amq.direct",
        queue,
        testData,
        {
              confirm: true
            },
        done);
          },
        next);
        },
        function(next) {
          return consumer = amqp.consume(queue,
        {
            prefetchCount: 1
          },
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        }
      ]);
    });
    it('test we can consumer cancel notify', function(done) {
      var amqp, consumer, messageProcessor, messagesRecieved, queue, queueObj, testData;
      testData = {
        test: "message"
      };
      amqp = null;
      queue = uuid();
      messagesRecieved = 0;
      consumer = null;
      queueObj = null;
      messageProcessor = function(m) {
        return console.error(m);
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost',
            clientProperties: {
              capabilities: {
                consumer_cancel_notify: true
              }
            }
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue,
            autoDelete: false
          },
        function(e,
        q) {
            queueObj = q;
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return consumer = amqp.consume(queue,
        {
            prefetchCount: 1
          },
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          consumer.on('error',
        function(err,
        res) {
            should.exist(err);
            err.code.should.eql("basicCancel");
            return done();
          });
          return queueObj.delete(next);
        }
      ], function(err, res) {
        should.not.exist(err);
        return amqp.close();
      });
    });
    it('test we can consumer cancel notify with cancel listener', function(done) {
      var amqp, consumer, messageProcessor, messagesRecieved, queue, queueObj, testData;
      testData = {
        test: "message"
      };
      amqp = null;
      queue = uuid();
      messagesRecieved = 0;
      consumer = null;
      queueObj = null;
      messageProcessor = function(m) {
        return console.error(m);
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost',
            clientProperties: {
              capabilities: {
                consumer_cancel_notify: true
              }
            }
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue,
            autoDelete: false
          },
        function(e,
        q) {
            queueObj = q;
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return consumer = amqp.consume(queue,
        {
            prefetchCount: 1
          },
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          consumer.on('error',
        function(err,
        res) {
            return should.not.exist(true);
          });
          consumer.on('cancel',
        function(err,
        res) {
            should.exist(err);
            err.should.eql("Server initiated basicCancel");
            return done();
          });
          return queueObj.delete(next);
        }
      ], function(err, res) {
        should.not.exist(err);
        return amqp.close();
      });
    });
    it('test we can consume and interrupt a autoDelete queue 854', function(done) {
      var amqp, consumer, messageProcessor, messagesRecieved, queue, testData, thisproxy;
      thisproxy = new proxy.route(7007, 5672, "localhost");
      amqp = null;
      testData = {
        test: "message"
      };
      amqp = null;
      queue = uuid();
      messagesRecieved = 0;
      consumer = null;
      messageProcessor = function(m) {
        m.data.should.eql(testData);
        messagesRecieved++;
        if (messagesRecieved === 5) {
          thisproxy.interrupt();
        }
        return m.ack();
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost',
            port: 7007
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue,
            autoDelete: true
          },
        function(e,
        q) {
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return async.forEach([0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
        function(i,
        done) {
            return amqp.publish("amq.direct",
        queue,
        testData,
        {
              confirm: true
            },
        done);
          },
        next);
        },
        function(next) {
          consumer = amqp.consume(queue,
        {
            prefetchCount: 1
          },
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
          return consumer.on('error',
        function(error) {
            should.exist(error);
            error.error.replyCode.should.eql(404);
            return amqp.close(function() {
              thisproxy.close();
              return done();
            });
          });
        }
      ]);
    });
    it('test we can consume and interrupt a nameless queue 806', function(done) {
      var amqp, consumer, errorCount, messageProcessor, messagesRecieved, queue, testData, thisproxy;
      this.timeout = 60000;
      thisproxy = new proxy.route(7007, 5672, "localhost");
      amqp = null;
      testData = {
        test: "message"
      };
      amqp = null;
      messagesRecieved = 0;
      consumer = null;
      queue = null;
      errorCount = 0;
      messageProcessor = function(m) {
        messagesRecieved++;
        thisproxy.interrupt();
        return _.delay(function() {
          return consumer.resume();
        }, 25);
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost',
            port: 7007
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue: ""
          },
        function(e,
        q) {
            should.not.exist(e);
            return q.declare(function() {
              queue = q.queueOptions.queue;
              return next();
            });
          });
        },
        function(next) {
          consumer = amqp.consume(queue,
        {
            prefetchCount: 1
          },
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
          return consumer.on('error',
        function(error) {
            should.exist(error);
            error.error.replyCode.should.eql(404);
            errorCount++;
            if (errorCount === 1) {
              messagesRecieved.should.eql(1);
              return _.delay(function() {
                errorCount.should.eql(1);
                return amqp.close(function() {
                  thisproxy.close();
                  return done();
                });
              },
        300);
            }
          });
        },
        function(next) {
          return amqp.publish("",
        queue,
        testData,
        {
            confirm: true
          },
        next);
        }
      ]);
    });
    it('test we can consume and interrupt a nameless queue with resume 807', function(done) {
      var amqp, consumer, errorCount, messageProcessor, messagesRecieved, queue, testData, thisproxy;
      this.timeout = 60000;
      thisproxy = new proxy.route(7008, 5672, "localhost");
      amqp = null;
      testData = {
        test: "message"
      };
      amqp = null;
      messagesRecieved = 0;
      consumer = null;
      queue = null;
      errorCount = 0;
      messageProcessor = function(m) {
        messagesRecieved++;
        thisproxy.interrupt();
        return _.delay(function() {
          return consumer.resume();
        }, 25);
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost',
            port: 7008
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue: ""
          },
        function(e,
        q) {
            should.not.exist(e);
            return q.declare(function() {
              queue = q.queueOptions.queue;
              return next();
            });
          });
        },
        function(next) {
          consumer = amqp.consume(queue,
        {
            prefetchCount: 1
          },
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
          return consumer.on('error',
        function(error) {
            should.exist(error);
            error.error.replyCode.should.eql(404);
            errorCount++;
            if (errorCount === 1) {
              return _.delay(function() {
                errorCount.should.eql(1);
                messagesRecieved.should.eql(1);
                return amqp.close(function() {
                  thisproxy.close();
                  return done();
                });
              },
        300);
            }
          });
        },
        function(next) {
          return amqp.publish("",
        queue,
        testData,
        {
            confirm: true
          },
        next);
        }
      ]);
    });
    it('test we can consume and interrupt a nameless queue with close 807.5', function(done) {
      var amqp, consumer, errorCount, messageProcessor, messagesRecieved, queue, testData, thisproxy;
      this.timeout = 60000;
      thisproxy = new proxy.route(7008, 5672, "localhost");
      amqp = null;
      testData = {
        test: "message"
      };
      amqp = null;
      messagesRecieved = 0;
      consumer = null;
      queue = null;
      errorCount = 0;
      messageProcessor = function(m) {
        messagesRecieved++;
        thisproxy.interrupt();
        return _.delay(function() {
          return consumer.close();
        }, 500);
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost',
            port: 7008
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue: ""
          },
        function(e,
        q) {
            should.not.exist(e);
            return q.declare(function() {
              queue = q.queueOptions.queue;
              return next();
            });
          });
        },
        function(next) {
          consumer = amqp.consume(queue,
        {
            prefetchCount: 1
          },
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
          return consumer.on('error',
        function(error) {
            should.exist(error);
            error.error.replyCode.should.eql(404);
            errorCount++;
            if (errorCount === 1) {
              return _.delay(function() {
                errorCount.should.eql(1);
                messagesRecieved.should.eql(1);
                return amqp.close(function() {
                  thisproxy.close();
                  return done();
                });
              },
        300);
            }
          });
        },
        function(next) {
          return amqp.publish("",
        queue,
        testData,
        {
            confirm: true
          },
        next);
        }
      ]);
    });
    it('test we can close a consumer channel 854.5', function(done) {
      var amqp, consumer, messageProcessor, messagesRecieved, queue, testData;
      amqp = null;
      testData = {
        test: "message"
      };
      amqp = null;
      queue = uuid();
      messagesRecieved = 0;
      consumer = null;
      messageProcessor = function(m) {
        m.data.should.eql(testData);
        messagesRecieved++;
        if (messagesRecieved === 5) {
          consumer.close();
          _.delay(function() {
            (messagesRecieved > 6).should.eql(false);
            return done();
          }, 200);
        }
        return m.ack();
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost',
            port: 5672
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue,
            autoDelete: false
          },
        function(e,
        q) {
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return async.forEach([0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
        function(i,
        done) {
            return amqp.publish("amq.direct",
        queue,
        testData,
        {
              confirm: true
            },
        done);
          },
        next);
        },
        function(next) {
          return consumer = amqp.consume(queue,
        {
            prefetchCount: 1
          },
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        }
      ]);
    });
    it('test we can consume and interrupt midstream and get all the messages 855', function(done) {
      var amqp, consumer, messageProcessor, messagesRecieved, queue, testData, thisproxy;
      thisproxy = new proxy.route(7003, 5672, "localhost");
      amqp = null;
      testData = {
        test: "message"
      };
      amqp = null;
      queue = uuid();
      messagesRecieved = 0;
      consumer = null;
      messageProcessor = function(m) {
        m.data.should.eql(testData);
        messagesRecieved++;
        if (messagesRecieved === 5) {
          thisproxy.interrupt();
        }
        if (messagesRecieved === 10) {
          done();
        }
        return m.ack();
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost',
            port: 7003
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({
            queue,
            autoDelete: false
          },
        function(e,
        q) {
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return async.forEach([0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
        function(i,
        done) {
            return amqp.publish("amq.direct",
        queue,
        testData,
        {
              confirm: true
            },
        done);
          },
        next);
        },
        function(next) {
          return consumer = amqp.consume(queue,
        {
            prefetchCount: 1
          },
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        }
      ]);
    });
    it('test we can consume a undefined message 856', function(done) {
      var amqp, consumer, messageProcessor, queue;
      amqp = null;
      queue = uuid();
      consumer = null;
      messageProcessor = function(m) {
        (m.data === void 0).should.eql(true);
        consumer.close();
        return done();
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({queue},
        function(e,
        q) {
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return amqp.publish("amq.direct",
        queue,
        void 0,
        {
            confirm: true
          },
        next);
        },
        function(next) {
          return consumer = amqp.consume(queue,
        {},
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        }
      ]);
    });
    it('test we can consume a null message 857', function(done) {
      var amqp, consumer, messageProcessor, queue;
      amqp = null;
      queue = uuid();
      consumer = null;
      messageProcessor = function(m) {
        (m.data === null).should.eql(true);
        consumer.close();
        return done();
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({queue},
        function(e,
        q) {
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return amqp.publish("amq.direct",
        queue,
        null,
        {
            confirm: true
          },
        next);
        },
        function(next) {
          return consumer = amqp.consume(queue,
        {},
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        }
      ]);
    });
    it('test we can consume a zero length message 858', function(done) {
      var amqp, consumer, messageProcessor, queue;
      amqp = null;
      queue = uuid();
      consumer = null;
      messageProcessor = function(m) {
        var zeroLengthBuffer;
        zeroLengthBuffer = Buffer.alloc(0);
        (m.data.toString() === zeroLengthBuffer.toString()).should.eql(true);
        consumer.close();
        return done();
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue({queue},
        function(e,
        q) {
            return q.declare(function() {
              return q.bind("amq.direct",
        queue,
        next);
            });
          });
        },
        function(next) {
          return amqp.publish("amq.direct",
        queue,
        Buffer.alloc(0),
        {
            confirm: true
          },
        next);
        },
        function(next) {
          return consumer = amqp.consume(queue,
        {},
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        }
      ]);
    });
    return it('test acknowledging multiple deliveries', function(done) {
      var amqp, checkSuccess, consumer, messageProcessor, queue, queueName, queueOptions;
      amqp = null;
      consumer = null;
      queueName = uuid();
      queueOptions = {
        queue: queueName,
        autoDelete: false,
        durable: true
      };
      queue = null;
      checkSuccess = function(m) {
        m.deliveryTag.should.eql(1);
        m.data.value.should.eql(3);
        return done();
      };
      messageProcessor = function(m) {
        if (m.deliveryTag === 2) {
          consumer.multiAck(2);
        }
        if (m.deliveryTag === 3) {
          return async.series([
            function(next) {
              return consumer.close(next);
            },
            function(next) {
              return queue.messageCount(queueOptions,
            function(e,
            c) {
                should.not.exist(e);
                c.should.eql(1);
                return next();
              });
            },
            function(next) {
              return queue.consumerCount(queueOptions,
            function(e,
            c) {
                should.not.exist(e);
                c.should.eql(0);
                return next();
              });
            },
            function(next) {
              return consumer = amqp.consume(queueName,
            {},
            checkSuccess,
            function(e,
            r) {
                should.not.exist(e);
                return next();
              });
            }
          ]);
        }
      };
      return async.series([
        function(next) {
          return amqp = new AMQP({
            host: 'localhost'
          },
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.queue(queueOptions,
        function(e,
        q) {
            queue = q;
            return q.declare(function() {
              return q.bind("amq.direct",
        queueName,
        next);
            });
          });
        },
        function(next) {
          return consumer = amqp.consume(queueName,
        {
            prefetchCount: 3
          },
        messageProcessor,
        function(e,
        r) {
            should.not.exist(e);
            return next();
          });
        },
        function(next) {
          return amqp.publish("amq.direct",
        queueName,
        {
            value: 1
          },
        {
            confirm: true
          },
        next);
        },
        function(next) {
          return amqp.publish("amq.direct",
        queueName,
        {
            value: 2
          },
        {
            confirm: true
          },
        next);
        },
        function(next) {
          return setTimeout(next,
        500);
        },
        function(next) {
          return amqp.publish("amq.direct",
        queueName,
        {
            value: 3
          },
        {
            confirm: true
          },
        next);
        }
      ]);
    });
  });

}).call(this);
